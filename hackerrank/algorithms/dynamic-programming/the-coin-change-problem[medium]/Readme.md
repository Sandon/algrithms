# 分析

f(i,j) 为用前j种币拼出总额i的最多的方式

初始
f(0, j) = 1

1、总额的维度



2、币的维度
j = 1 时
f(i,j) = i%c[j] === 0 ? 1 : 0 

j>= 2 时
包含j: 
    包含1次：f(i-1*c[j], j-1)
    包含2次：f(i-2*c[j], j-1)
    ...
    包含最多 Math.floor(i/c[j]) 次
不包含j: f(i, j-1)

f(i, j) 就是他们的和

[2]
f(6, 1) = f(6, 0) + f(4, 0) + f(2, 0) + f(0, 0) = 0 // 这是错的
f(6, 1) = 1 // 原因 6/2 === 0 ? 1 : 0

[2, 3, 5]
f(6, 2) = f(6, 1) + f(3, 1) + f(0, 1) = 1 + 0 + 1
f(10, 3) = f(10, 2) + f(5, 2) + f(0, 2) =
